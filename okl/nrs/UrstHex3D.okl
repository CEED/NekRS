@kernel void UrstCubatureHex3D(const dlong Nelements,
                               @restrict const  dfloat *D,
                               @restrict const  dfloat *x,
                               @restrict const  dfloat *y,
                               @restrict const  dfloat *z,
                               @restrict const dfloat* cubInterpT,
                               @restrict const dfloat* cubW,
                               const dlong offset,
                               const dlong cubatureOffset,
                               @restrict const dfloat*  U,
                               @restrict const dfloat*  W,
                               @restrict dfloat*  result)
{
  for(dlong element = 0; element < Nelements; ++element; @outer(0)) {
    @shared dfloat s_cubInterpT[p_Nq][p_cubNq];

    @shared dfloat s_U[p_Nq][p_Nq];
    @shared dfloat s_V[p_Nq][p_Nq];
    @shared dfloat s_W[p_Nq][p_Nq];

// reuse smem
#define s_x s_U
#define s_y s_V
#define s_z s_W

    @shared dfloat s_U1[p_Nq][p_cubNq];
    @shared dfloat s_V1[p_Nq][p_cubNq];
    @shared dfloat s_W1[p_Nq][p_cubNq];

//reuse smem
#define s_cubxre s_U1
#define s_cubxse s_V1
#define s_cubxte s_W1

    @exclusive dfloat r_U[p_cubNq], r_V[p_cubNq], r_W[p_cubNq];

// reuse reg
#define r_x r_U
#define r_y r_V
#define r_z r_W

    @shared dfloat s_D[p_Nq][p_Nq];

    @shared dfloat s_xre[p_Nq][p_Nq];
    @shared dfloat s_xse[p_Nq][p_Nq];
    @shared dfloat s_xte[p_Nq][p_Nq];

    @shared dfloat s_yre[p_Nq][p_Nq];
    @shared dfloat s_yse[p_Nq][p_Nq];
    @shared dfloat s_yte[p_Nq][p_Nq];
    
    @shared dfloat s_zre[p_Nq][p_Nq];
    @shared dfloat s_zse[p_Nq][p_Nq];
    @shared dfloat s_zte[p_Nq][p_Nq];

    @shared dfloat s_cubyre[p_Nq][p_cubNq];
    @shared dfloat s_cubyse[p_Nq][p_cubNq];
    @shared dfloat s_cubyte[p_Nq][p_cubNq];

    @shared dfloat s_cubzre[p_Nq][p_cubNq];
    @shared dfloat s_cubzse[p_Nq][p_cubNq];
    @shared dfloat s_cubzte[p_Nq][p_cubNq];

    @exclusive dfloat r_cubxre[p_cubNq];
    @exclusive dfloat r_cubxse[p_cubNq];
    @exclusive dfloat r_cubxte[p_cubNq];

    @exclusive dfloat r_cubyre[p_cubNq];
    @exclusive dfloat r_cubyse[p_cubNq];
    @exclusive dfloat r_cubyte[p_cubNq];

    @exclusive dfloat r_cubzre[p_cubNq];
    @exclusive dfloat r_cubzse[p_cubNq];
    @exclusive dfloat r_cubzte[p_cubNq];

    @shared dfloat s_cubW[p_cubNq];


    for(int j = 0; j < p_cubNq; ++j; @inner(1)) {
      for(int i = 0; i < p_cubNq; ++i; @inner(0)) {
        const int id = i + j * p_cubNq;

        if(j==0) s_cubW[i] = cubW[i];

        if (id < p_Nq * p_cubNq) s_cubInterpT[j][i] = cubInterpT[id]; 

#pragma unroll p_cubNq
        for(int k = 0; k < p_cubNq; ++k) {

          r_cubxre[k] = 0;
          r_cubxse[k] = 0;
          r_cubxte[k] = 0;

          r_cubyre[k] = 0;
          r_cubyse[k] = 0;
          r_cubyte[k] = 0;

          r_cubzre[k] = 0;
          r_cubzse[k] = 0;
          r_cubzte[k] = 0;
        }
      }
    }
    @barrier("local");

//    #pragma unroll p_Nq
    for(int k = 0 ; k < p_Nq; ++k){
      for(int j=0;j<p_cubNq;++j;@inner(1)){
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(i < p_Nq && j < p_Nq){
            s_D[j][i]  = D[j*p_Nq+i];
            const dlong id = element*p_Np + k*p_Nq*p_Nq + j*p_Nq + i;
            s_x[j][i] = x[id];
            s_y[j][i] = y[id];
            s_z[j][i] = z[id];
            if(k == 0){
              #pragma unroll p_Nq
              for(int l = 0 ; l < p_Nq; ++l){
                const dlong other_id = element*p_Np + l*p_Nq*p_Nq + j*p_Nq + i;
                r_x[l] = x[other_id];
                r_y[l] = y[other_id];
                r_z[l] = z[other_id];
              }
            }
          }
        }
      }
      @barrier("local");
      for(int j=0;j<p_cubNq;++j;@inner(1)){
        for(int i=0;i<p_cubNq;++i;@inner(0)){
          if(i < p_Nq && j < p_Nq){
            dfloat xr = 0, yr = 0, zr = 0;
            dfloat xs = 0, ys = 0, zs = 0;
            dfloat xt = 0, yt = 0, zt = 0;
            #pragma unroll p_Nq
            for(int m=0;m<p_Nq;++m){
              const dfloat Dim = s_D[i][m];
              const dfloat Djm = s_D[j][m];
              const dfloat Dkm = s_D[k][m];
              xr += Dim*s_x[j][m];
              xs += Djm*s_x[m][i];
              xt += Dkm*r_x[m];
              yr += Dim*s_y[j][m];
              ys += Djm*s_y[m][i];
              yt += Dkm*r_y[m];
              zr += Dim*s_z[j][m];
              zs += Djm*s_z[m][i];
              zt += Dkm*r_z[m];
            }
            // store results in shmem array
            s_xre[j][i] = xr;
            s_xse[j][i] = xs;
            s_xte[j][i] = xt;

            s_yre[j][i] = yr;
            s_yse[j][i] = ys;
            s_yte[j][i] = yt;

            s_zre[j][i] = zr;
            s_zse[j][i] = zs;
            s_zte[j][i] = zt;
          }
        }
      }
      @barrier("local");
      for(int b = 0; b < p_cubNq; ++b; @inner(1))
        for(int i = 0; i < p_cubNq; ++i; @inner(0))
          if(b < p_Nq) {
            dfloat xr1  = 0, xs1 = 0,  xt1 = 0;
            dfloat yr1  = 0, ys1 = 0,  yt1 = 0;
            dfloat zr1  = 0, zs1 = 0,  zt1 = 0;
            for(int a = 0; a < p_Nq; ++a) {
              dfloat Iia = s_cubInterpT[a][i];
              xr1  += Iia * s_xre[b][a];
              xs1  += Iia * s_xse[b][a];
              xt1  += Iia * s_xte[b][a];

              yr1  += Iia * s_yre[b][a];
              ys1  += Iia * s_yse[b][a];
              yt1  += Iia * s_yte[b][a];

              zr1  += Iia * s_zre[b][a];
              zs1  += Iia * s_zse[b][a];
              zt1  += Iia * s_zte[b][a];
            }

            s_cubxre[b][i] = xr1;
            s_cubxse[b][i] = xs1;
            s_cubxte[b][i] = xt1;

            s_cubyre[b][i] = yr1;
            s_cubyse[b][i] = ys1;
            s_cubyte[b][i] = yt1;

            s_cubzre[b][i] = zr1;
            s_cubzse[b][i] = zs1;
            s_cubzte[b][i] = zt1;

          }

      @barrier("local");

      // interpolate in 's'
      for(int j = 0; j < p_cubNq; ++j; @inner(1))
        for(int i = 0; i < p_cubNq; ++i; @inner(0)) {
          dfloat xr2  = 0, xs2 = 0,  xt2 = 0;
          dfloat yr2  = 0, ys2 = 0,  yt2 = 0;
          dfloat zr2  = 0, zs2 = 0,  zt2 = 0;
          // interpolate in b
          for(int b = 0; b < p_Nq; ++b) {
            dfloat Ijb = s_cubInterpT[b][j];
            xr2 += Ijb * s_cubxre[b][i];
            xs2 += Ijb * s_cubxse[b][i];
            xt2 += Ijb * s_cubxte[b][i];

            yr2 += Ijb * s_cubyre[b][i];
            ys2 += Ijb * s_cubyse[b][i];
            yt2 += Ijb * s_cubyte[b][i];

            zr2 += Ijb * s_cubzre[b][i];
            zs2 += Ijb * s_cubzse[b][i];
            zt2 += Ijb * s_cubzte[b][i];
          }

          // interpolate in k progressively
          #pragma unroll p_cubNq 
          for(int c = 0; c < p_cubNq; ++c) {
            dfloat Ick = s_cubInterpT[k][c];
            r_cubxre[c] += Ick * xr2;
            r_cubxse[c] += Ick * xs2;
            r_cubxte[c] += Ick * xt2;

            r_cubyre[c] += Ick * yr2;
            r_cubyse[c] += Ick * ys2;
            r_cubyte[c] += Ick * yt2;

            r_cubzre[c] += Ick * zr2;
            r_cubzse[c] += Ick * zs2;
            r_cubzte[c] += Ick * zt2;
          }
        }
      @barrier("local");
    }

    for(int c = 0; c < p_Nq; ++c) {
      @barrier("local");

      for(int b = 0; b < p_cubNq; ++b; @inner(1))
        for(int a = 0; a < p_cubNq; ++a; @inner(0)){
          if(c == 0){
            #pragma unroll p_cubNq
            for(int k = 0; k < p_cubNq; ++k){
              r_U[k] = 0.0;
              r_V[k] = 0.0;
              r_W[k] = 0.0;
            }
          }
          if(a < p_Nq && b < p_Nq) {
            const dlong id = element * p_Np + c * p_Nq * p_Nq + b * p_Nq + a;

            dfloat Ue = U[id + 0 * offset];
            dfloat Ve = U[id + 1 * offset];
            dfloat We = U[id + 2 * offset];
            if(p_relative){
              Ue -= W[id + 0 * offset];
              Ve -= W[id + 1 * offset];
              We -= W[id + 2 * offset];
            }

            s_U[b][a] = Ue;
            s_V[b][a] = Ve;
            s_W[b][a] = We;
          }
        }

      @barrier("local");

      // interpolate in 'r'
      for(int b = 0; b < p_cubNq; ++b; @inner(1))
        for(int i = 0; i < p_cubNq; ++i; @inner(0))
          if(b < p_Nq) {
            dfloat U1  = 0, V1 = 0,  W1 = 0;

            for(int a = 0; a < p_Nq; ++a) {
              dfloat Iia = s_cubInterpT[a][i];
              U1  += Iia * s_U[b][a];
              V1  += Iia * s_V[b][a];
              W1  += Iia * s_W[b][a];
            }

            s_U1[b][i] = U1;
            s_V1[b][i] = V1;
            s_W1[b][i] = W1;
          }

      @barrier("local");

      // interpolate in 's'
      for(int j = 0; j < p_cubNq; ++j; @inner(1)) {
        for(int i = 0; i < p_cubNq; ++i; @inner(0)) {
          dfloat U2 = 0, V2 = 0,  W2 = 0;

          // interpolate in b
          for(int b = 0; b < p_Nq; ++b) {
            dfloat Ijb = s_cubInterpT[b][j];
            U2 += Ijb * s_U1[b][i];
            V2 += Ijb * s_V1[b][i];
            W2 += Ijb * s_W1[b][i];
          }

          // interpolate in c progressively
#pragma unroll p_cubNq
          for(int k = 0; k < p_cubNq; ++k) {
            dfloat Ikc = s_cubInterpT[c][k];
            r_U[k] += Ikc * U2;
            r_V[k] += Ikc * V2;
            r_W[k] += Ikc * W2;
          }
        }
      }
    }

#pragma unroll p_cubNq
    for(int k = 0; k < p_cubNq; ++k) {

      @barrier("local");

      for(int j = 0; j < p_cubNq; ++j; @inner(1))
        for(int i = 0; i < p_cubNq; ++i; @inner(0)) {
          const dfloat xr = r_cubxre[k], xs = r_cubxse[k], xt = r_cubxte[k];
          const dfloat yr = r_cubyre[k], ys = r_cubyse[k], yt = r_cubyte[k];
          const dfloat zr = r_cubzre[k], zs = r_cubzse[k], zt = r_cubzte[k];

          const dfloat drdx =  (ys * zt - zs * yt);
          const dfloat drdy = -(xs * zt - zs * xt);
          const dfloat drdz =  (xs * yt - ys * xt);

          const dfloat dsdx = -(yr * zt - zr * yt);
          const dfloat dsdy =  (xr * zt - zr * xt);
          const dfloat dsdz = -(xr * yt - yr * xt);

          const dfloat dtdx =  (yr * zs - zr * ys);
          const dfloat dtdy = -(xr * zs - zr * xs);
          const dfloat dtdz =  (xr * ys - yr * xs);

          const dfloat W = s_cubW[i] * s_cubW[j] * s_cubW[k];

          const dfloat Un = r_U[k];
          const dfloat Vn = r_V[k];
          const dfloat Wn = r_W[k];

          const dlong id = element * p_cubNp + k * p_cubNq * p_cubNq + j * p_cubNq + i;
          result[id + 0 * cubatureOffset] = W * (Un * drdx + Vn * drdy + Wn * drdz);
          result[id + 1 * cubatureOffset] = W * (Un * dsdx + Vn * dsdy + Wn * dsdz);
          result[id + 2 * cubatureOffset] = W * (Un * dtdx + Vn * dtdy + Wn * dtdz);
        }
    }
  }
}
@kernel void UrstHex3D(const dlong Nelements,
                                          @restrict const dfloat*  vgeo,
                                          const dlong offset,
                                          @restrict const dfloat*  U,
                                          @restrict const dfloat*  W,
                                          @restrict dfloat*  result)
{
  for(dlong element = 0; element < Nelements; ++element; @outer(0)) {

    #pragma unroll p_Nq
    for(int k = 0; k < p_Nq; ++k){

    @barrier("local");

      for(int j = 0; j < p_Nq; ++j; @inner(1)) {
        for(int i = 0; i < p_Nq; ++i; @inner(0)) {
          const dlong gid = element * p_Np * p_Nvgeo + k * p_Nq * p_Nq + j * p_Nq + i;
          const dfloat drdx = vgeo[gid + p_RXID * p_Np];
          const dfloat drdy = vgeo[gid + p_RYID * p_Np];
          const dfloat drdz = vgeo[gid + p_RZID * p_Np];
          const dfloat dsdx = vgeo[gid + p_SXID * p_Np];
          const dfloat dsdy = vgeo[gid + p_SYID * p_Np];
          const dfloat dsdz = vgeo[gid + p_SZID * p_Np];
          const dfloat dtdx = vgeo[gid + p_TXID * p_Np];
          const dfloat dtdy = vgeo[gid + p_TYID * p_Np];
          const dfloat dtdz = vgeo[gid + p_TZID * p_Np];
          const dfloat JW = vgeo[gid + p_JWID * p_Np];

          const dlong id = element * p_Np + k * p_Nq * p_Nq + j * p_Nq + i;

          dfloat Un = U[id + 0 * offset];
          dfloat Vn = U[id + 1 * offset];
          dfloat Wn = U[id + 2 * offset];
          if(p_relative){
            Un -= W[id + 0 * offset];
            Vn -= W[id + 1 * offset];
            Wn -= W[id + 2 * offset];
          }

          const dfloat Uhat = JW * (Un * drdx + Vn * drdy + Wn * drdz);
          const dfloat Vhat = JW * (Un * dsdx + Vn * dsdy + Wn * dsdz);
          const dfloat What = JW * (Un * dtdx + Vn * dtdy + Wn * dtdz);

          result[id + 0 * offset] =  Uhat;
          result[id + 1 * offset] =  Vhat;
          result[id + 2 * offset] =  What;
        }
      }
    }
  }
}
